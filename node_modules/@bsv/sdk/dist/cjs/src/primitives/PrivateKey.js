"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyShares = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const PublicKey_js_1 = __importDefault(require("./PublicKey.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const ECDSA_js_1 = require("./ECDSA.js");
const Hash_js_1 = require("./Hash.js");
const Random_js_1 = __importDefault(require("./Random.js"));
const utils_js_1 = require("./utils.js");
const Polynomial_js_1 = __importStar(require("./Polynomial.js"));
/**
 * @class KeyShares
 *
 * This class is used to store the shares of a private key.
 *
 * @param shares - An array of shares
 * @param threshold - The number of shares required to recombine the private key
 *
 * @returns KeyShares
 *
 * @example
 * const key = PrivateKey.fromShares(shares)
 *
 */
class KeyShares {
    constructor(points, threshold, integrity) {
        this.points = points;
        this.threshold = threshold;
        this.integrity = integrity;
    }
    static fromBackupFormat(shares) {
        let threshold = 0;
        let integrity = '';
        const points = shares.map((share, idx) => {
            const shareParts = share.split('.');
            if (shareParts.length !== 4)
                throw Error('Invalid share format in share ' + idx + '. Expected format: "x.y.t.i" - received ' + share);
            const [x, y, t, i] = shareParts;
            if (!t)
                throw Error('Threshold not found in share ' + idx);
            if (!i)
                throw Error('Integrity not found in share ' + idx);
            const tInt = parseInt(t);
            if (idx !== 0 && threshold !== tInt)
                throw Error('Threshold mismatch in share ' + idx);
            if (idx !== 0 && integrity !== i)
                throw Error('Integrity mismatch in share ' + idx);
            threshold = tInt;
            integrity = i;
            return Polynomial_js_1.PointInFiniteField.fromString([x, y].join('.'));
        });
        return new KeyShares(points, threshold, integrity);
    }
    toBackupFormat() {
        return this.points.map(share => share.toString() + '.' + this.threshold + '.' + this.integrity);
    }
}
exports.KeyShares = KeyShares;
/**
 * Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.
 *
 * The `PrivateKey` class extends from the `BigNumber` class. It offers methods to create signatures, verify them,
 * create a corresponding public key and derive a shared secret from a public key.
 *
 * @extends {BigNumber}
 * @see {@link BigNumber} for more information on BigNumber.
 */
class PrivateKey extends BigNumber_js_1.default {
    /**
     * Generates a private key randomly.
     *
     * @method fromRandom
     * @static
     * @returns The newly generated Private Key.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     */
    static fromRandom() {
        return new PrivateKey((0, Random_js_1.default)(32));
    }
    /**
     * Generates a private key from a string.
     *
     * @method fromString
     * @static
     * @param str - The string to generate the private key from.
     * @param base - The base of the string.
     * @returns The generated Private Key.
     * @throws Will throw an error if the string is not valid.
     **/
    static fromString(str, base) {
        return new PrivateKey(BigNumber_js_1.default.fromString(str, base).toArray());
    }
    /**
     * Generates a private key from a WIF (Wallet Import Format) string.
     *
     * @method fromWif
     * @static
     * @param wif - The WIF string to generate the private key from.
     * @param base - The base of the string.
     * @returns The generated Private Key.
     * @throws Will throw an error if the string is not a valid WIF.
     **/
    static fromWif(wif, prefixLength = 1) {
        const decoded = (0, utils_js_1.fromBase58Check)(wif, null, prefixLength);
        if (decoded.data.length !== 33) {
            throw new Error('Invalid WIF length');
        }
        if (decoded.data[32] !== 1) {
            throw new Error('Invalid WIF padding');
        }
        return new PrivateKey(decoded.data.slice(0, 32));
    }
    /**
     * @constructor
     *
     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
     *
     * @param base - The base of number provided. By default is 10. Ignored if number is BigNumber.
     *
     * @param endian - The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.
     *
     * @param modN - Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw Error('Input is out of field'). If 'nocheck', assumes input is in field.
     *
     * @example
     * import PrivateKey from './PrivateKey';
     * import BigNumber from './BigNumber';
     * const privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));
     */
    constructor(number = 0, base = 10, endian = 'be', modN = 'apply') {
        if (number instanceof BigNumber_js_1.default) {
            super();
            number.copy(this);
        }
        else {
            super(number, base, endian);
        }
        if (modN !== 'nocheck') {
            const check = this.checkInField();
            if (!check.inField) {
                if (modN === 'error') {
                    throw new Error('Input is out of field');
                }
                // Force the PrivateKey BigNumber value to lie in the field limited by curve.n
                BigNumber_js_1.default.move(this, check.modN);
            }
        }
    }
    /**
     * A utility function to check that the value of this PrivateKey lies in the field limited by curve.n
     * @returns { inField, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.
     */
    checkInField() {
        const curve = new Curve_js_1.default();
        const modN = this.mod(curve.n);
        const inField = this.cmp(modN) === 0;
        return { inField, modN };
    }
    /**
     * @returns true if the PrivateKey's current BigNumber value lies in the field limited by curve.n
     */
    isValid() {
        return this.checkInField().inField;
    }
    /**
     * Signs a message using the private key.
     *
     * @method sign
     * @param msg - The message (array of numbers or string) to be signed.
     * @param enc - If 'hex' the string will be treated as hex, utf8 otherwise.
     * @param forceLowS - If true (the default), the signature will be forced to have a low S value.
     * @param customK â€” If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.
     * @returns A digital signature generated from the hash of the message and the private key.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const signature = privateKey.sign('Hello, World!');
     */
    sign(msg, enc, forceLowS = true, customK) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.sign)(msgHash, this, forceLowS, customK);
    }
    /**
     * Verifies a message's signature using the public key associated with this private key.
     *
     * @method verify
     * @param msg - The original message which has been signed.
     * @param sig - The signature to be verified.
     * @param enc - The data encoding method.
     * @returns Whether or not the signature is valid.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const signature = privateKey.sign('Hello, World!');
     * const isSignatureValid = privateKey.verify('Hello, World!', signature);
     */
    verify(msg, sig, enc) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.verify)(msgHash, sig, this.toPublicKey());
    }
    /**
     * Converts the private key to its corresponding public key.
     *
     * The public key is generated by multiplying the base point G of the curve and the private key.
     *
     * @method toPublicKey
     * @returns The generated PublicKey.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const publicKey = privateKey.toPublicKey();
     */
    toPublicKey() {
        const c = new Curve_js_1.default();
        const p = c.g.mul(this);
        return new PublicKey_js_1.default(p.x, p.y);
    }
    /**
     * Converts the private key to a Wallet Import Format (WIF) string.
     *
     * Base58Check encoding is used for encoding the private key.
     * The prefix
     *
     * @method toWif
     * @returns The WIF string.
     *
     * @param prefix defaults to [0x80] for mainnet, set it to [0xef] for testnet.
     *
     * @throws Error('Value is out of field') if current BigNumber value is out of field limited by curve.n
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const wif = privateKey.toWif();
     * const testnetWif = privateKey.toWif([0xef]);
     */
    toWif(prefix = [0x80]) {
        if (!this.isValid()) {
            throw new Error('Value is out of field');
        }
        return (0, utils_js_1.toBase58Check)([...this.toArray('be', 32), 1], prefix);
    }
    /**
     * Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type.
     * Defaults to P2PKH for mainnet, otherwise known as a "Bitcoin Address".
     *
     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'
     *
     * @returns Returns the address encoding associated with the hash of the public key associated with this private key.
     *
     * @example
     * const address = privkey.toAddress()
     * const address = privkey.toAddress('mainnet')
     * const testnetAddress = privkey.toAddress([0x6f])
     * const testnetAddress = privkey.toAddress('testnet')
     */
    toAddress(prefix = [0x00]) {
        return this.toPublicKey().toAddress(prefix);
    }
    /**
     * Derives a shared secret from the public key.
     *
     * @method deriveSharedSecret
     * @param key - The public key to derive the shared secret from.
     * @returns The derived shared secret (a point on the curve).
     * @throws Will throw an error if the public key is not valid.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const publicKey = privateKey.toPublicKey();
     * const sharedSecret = privateKey.deriveSharedSecret(publicKey);
     */
    deriveSharedSecret(key) {
        if (!key.validate()) {
            throw new Error('Public key not valid for ECDH secret derivation');
        }
        return key.mul(this);
    }
    /**
     * Derives a child key with BRC-42.
     * @param publicKey The public key of the other party
     * @param invoiceNumber The invoice number used to derive the child key
     * @returns The derived child key.
     */
    deriveChild(publicKey, invoiceNumber) {
        const sharedSecret = this.deriveSharedSecret(publicKey);
        const invoiceNumberBin = (0, utils_js_1.toArray)(invoiceNumber, 'utf8');
        const hmac = (0, Hash_js_1.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);
        const curve = new Curve_js_1.default();
        return new PrivateKey(this.add(new BigNumber_js_1.default(hmac)).mod(curve.n).toArray());
    }
    /**
     * Splits the private key into shares using Shamir's Secret Sharing Scheme.
     *
     * @param threshold The minimum number of shares required to reconstruct the private key.
     * @param totalShares The total number of shares to generate.
     * @param prime The prime number to be used in Shamir's Secret Sharing Scheme.
     * @returns An array of shares.
     *
     * @example
     * const key = PrivateKey.fromRandom()
     * const shares = key.toKeyShares(2, 5)
     */
    toKeyShares(threshold, totalShares) {
        if (typeof threshold !== 'number' || typeof totalShares !== 'number')
            throw new Error('threshold and totalShares must be numbers');
        if (threshold < 2)
            throw new Error('threshold must be at least 2');
        if (totalShares < 2)
            throw new Error('totalShares must be at least 2');
        if (threshold > totalShares)
            throw new Error('threshold should be less than or equal to totalShares');
        const poly = Polynomial_js_1.default.fromPrivateKey(this, threshold);
        const points = [];
        for (let i = 0; i < totalShares; i++) {
            const x = new BigNumber_js_1.default(PrivateKey.fromRandom().toArray());
            const y = poly.valueAt(x);
            points.push(new Polynomial_js_1.PointInFiniteField(x, y));
        }
        const integrity = this.toPublicKey().toHash('hex').slice(0, 8);
        return new KeyShares(points, threshold, integrity);
    }
    /**
     * @method toBackupShares
     *
     * Creates a backup of the private key by splitting it into shares.
     *
     *
     * @param threshold The number of shares which will be required to reconstruct the private key.
     * @param totalShares The number of shares to generate for distribution.
     * @returns
     */
    toBackupShares(threshold, totalShares) {
        return this.toKeyShares(threshold, totalShares).toBackupFormat();
    }
    /**
     *
     * @method fromBackupShares
     *
     * Creates a private key from backup shares.
     *
     * @param shares
     * @returns PrivateKey
     */
    static fromBackupShares(shares) {
        return PrivateKey.fromKeyShares(KeyShares.fromBackupFormat(shares));
    }
    /**
     * Combines shares to reconstruct the private key.
     *
     * @param shares An array of points (shares) to be used to reconstruct the private key.
     * @param threshold The minimum number of shares required to reconstruct the private key.
     *
     * @returns The reconstructed private key.
     *
     * @example
     * const share1 = '2NWeap6SDBTL5jVnvk9yUxyfLqNrDs2Bw85KNDfLJwRT.4yLtSm327NApsbuP7QXVW3CWDuBRgmS6rRiFkAkTukic'
     * const share2 = '7NbgGA8iAsxg2s6mBLkLFtGKQrnc4aCbooHJJV31cWs4.GUgXtudthawE3Eevc1waT3Atr1Ft7j1XxdUguVo3B7x3'
     * const reconstructedKey = PrivateKey.fromKeyShares({ shares: [share1, share2], threshold: 2, integrity: '23409547' })
     *
     **/
    static fromKeyShares(keyShares) {
        const { points, threshold, integrity } = keyShares;
        if (threshold < 2 || threshold > 99)
            throw new Error('threshold should be between 2 and 99');
        if (points.length < threshold)
            throw new Error(`At least ${threshold} shares are required to reconstruct the private key`);
        // check to see if two points have the same x value
        for (let i = 0; i < threshold; i++) {
            for (let j = i + 1; j < threshold; j++) {
                if (points[i].x.eq(points[j].x)) {
                    throw new Error('Duplicate share detected, each must be unique.');
                }
            }
        }
        const poly = new Polynomial_js_1.default(points, threshold);
        const privateKey = new PrivateKey(poly.valueAt(new BigNumber_js_1.default(0)).toArray());
        const integrityHash = privateKey.toPublicKey().toHash('hex').slice(0, 8);
        if (integrityHash !== integrity) {
            throw new Error('Integrity hash mismatch');
        }
        return privateKey;
    }
}
exports.default = PrivateKey;
//# sourceMappingURL=PrivateKey.js.map